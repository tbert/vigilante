#! /usr/bin/perl
#
# Copyright (c) 2013 Bret Stephen Lambert <bret@theapt.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

use strict;
use warnings;

use XML::Compile;
use XML::Compile::Schema;

use Getopt::Std;

use lib "lib/";		# XXX -- for testing only!

use Vigilante;

use feature "switch";

# XXX -- found online at http://permalink.gmane.org/gmane.comp.kde.devel.bugs/1022797,
#        xsd "generated by Trang"; what is the license for this, then?
#
# NB  -- there is also a potential schema at
#        https://bitbucket.org/ancechu/valgrind-reports-to-xunit/src/7c58733de895/xslt/valgrind_transform.xsl
#
my $valgrindschema = "./data/xmlschemas/valgrind-memcheck-xml-output.xsd";	# XXX

sub frameval($) {
	my $val = shift;

	if (defined($val)) {
		return $val;
	} else {
		return "???";
	}
}

sub errorclass($) {
	my $errstr = shift;

	given ($errstr) {
		when (/Leak_/)		{ return "LEAK"; }
		when ("SyscallParam")	{ return "INIT"; }
		default			{ die("Unknown error class $errstr"); }
	}
}

sub hashxml() {
	my $schema = XML::Compile::Schema->new($valgrindschema);
	my $reader = $schema->compile(READER => "valgrindoutput");

	return $reader->(\*STDIN);
}

my $report;
my $xmlhash;
my $project = undef;
my %opts;

getopt("p:", \%opts);

$project = $opts{"p"}	if (defined($opts{"p"}));

die("Project name not defined")		if (!defined($project));

$xmlhash = hashxml();

$report = Vigilante::Report->new();
$report->set_tool("valgrind");
$report->set_project($project);

foreach my $key (keys %{$xmlhash}) {

	if ($key eq "cho_error") {
		foreach my $err (@{$xmlhash->{$key}}) {

			if (!defined($err->{"error"})) {
				next;
			}

			my $defect = Vigilante::Defect->new();
			my $stackframe = $err->{"error"}->{"stack"}->{"frame"};
			my $backtrace = "";
			my $file;
			my $lineno;

			foreach my $frame (@{$stackframe}) {
				$backtrace .= frameval($frame->{"fn"}) . "():";
				$backtrace .= frameval($frame->{"file"}) . ":";
				$backtrace .= frameval($frame->{"line"}) . "\n";
			}

			if ($err->{"error"}->{"stack"}->{"frame"}[0]->{"file"} =~ /^vg_/) {
				$file = $err->{"error"}->{"stack"}->{"frame"}[1]->{"file"};
				$lineno = $err->{"error"}->{"stack"}->{"frame"}[1]->{"line"};
			} else {
				$file = $err->{"error"}->{"stack"}->{"frame"}[0]->{"file"};
				$lineno = $err->{"error"}->{"stack"}->{"frame"}[0]->{"line"};
			}

			$defect->set_file($file);
			$defect->set_lineno($lineno);
			$defect->set_errstr($err->{"error"}->{"cho_what"}[0]->{"xwhat"}->{"text"});
			$defect->set_class(errorclass($err->{"error"}->{"kind"}));
			$defect->set_defect_line($backtrace);
			$defect->set_raw("");			# XXX -- XML dump of just this defect?

			$report->append($defect);
		}
	}
}

$report->report(\*STDOUT);

exit 0;
